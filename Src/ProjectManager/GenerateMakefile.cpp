#include "GenerateMakefile.h"

namespace Makefile {

Generator::Generator()
{
    build.name = "Build";
    build.var = "MAIN_BUILD_DIR";
    target.var = "TARGET";

}

void Generator::setBuildDir(std::string build)
{
    this->build.name = build;
}

void Generator::setRootDir(std::string root)
{
    this->root = root;
}

void Generator::setTargetName(std::string target)
{
    this->target.name = target;
}

ToolIndex Generator::addTool(Tool tool)
{
    this->tools.push_back(tool);
    return (int)tools.size() - 1;
}

RuleIndex Generator::addRule(Rule rule)
{
    this->rules.push_back(rule);
    return (int)rules.size() - 1;
}

VariableIndex Generator::addVariable(Variable var)
{
    vars.push_back(var);
    return (int)vars.size() - 1;
}

void Generator::addIfeq(std::string ifElse, std::string acIf, std::string acElse)
{
    ifeq += "ifeq (" + ifElse + ")\n";
    ifeq += "\t" + acIf + "\n";
    if (!acElse.empty()) {
        ifeq += "else\n";
        ifeq += "\t" + acElse + "\n";
    }
    ifeq += "endif\n";

}

Error Generator::generate()
{
    std::string content;

//    content.addContent("#Generated by BitCoder").newLine()
//            .addContent("BUILD_DIR = ").addContent(build.c_str()).newLine().newLine();
    content += "#Generated by BitCoder\n";
    content += target.var + " = " + target.name + "\n";
    content += "\n";
    content += "#Build bir\n";
    content += build.var + " = " + build.name + "\n";
    content += "\n";

    content += "\n";
    content += "#Vars\n";
    for (auto it = vars.begin(); it != vars.end(); it++) {
        for (auto val_it = it->getVal().begin(); val_it != it->getVal().end(); val_it++) {
            if (it->getTypeVar() == TypeVariable::Assignment) {
                content += it->getName() + " := " + *val_it + "\n";
            }
            if (it->getTypeVar() == TypeVariable::None) {
                if (val_it == it->getVal().begin()) {
                    content += it->getName() + " = " + *val_it + "\n";
                }
                else {
                    content += it->getName() + " += " + *val_it + "\n";
                }
            }
        }
    }
    content += "\n";
    content += "#Tools\n";
    for (auto &it : tools) {
        content += it.getName() + " = " + it.getPath() + "\n";
    }
    content += "\n";
    content += ifeq;
    content += "\n";
    content += "#Rules\n";
    for (auto &it : rules) {
        content += it.getName() + ": " + it.getDep() + "\n";
        content += it.getActions() + "\n";
        content += "\n";
    }
    content += "\n";
    std::fstream file;
    if(root.empty()){
        return RootEmpty;
    }

    if (root.find_last_of('/') != root.size() - 1) {
        root += "/";
    }

    file.open(root + "Makefile", std::ios::out | std::ios::trunc | std::ios::binary);


    file << content.c_str();

    file.flush();
    file.close();
    return NoError;
}

std::string Generator::getBuildDir()
{
    return "$(" + build.var + ")";
}

std::string Generator::getNameBuildDir()
{
    return build.name;
}

std::string &Generator::getRootDir()
{
    return root;
}

std::string Generator::getTargetName()
{
    return "$(" + target.var + ")";
}

Variable *Generator::getVariable(VariableIndex index)
{
    if (index < 0 || index >= (int)vars.size()) {
        return NULL;
    }
    return &vars.at(index);
}

Rule *Generator::getRule(RuleIndex index)
{
    if (index < 0 || index >= (int)rules.size()) {
        return NULL;
    }
    return &rules.at(index);
}

Tool *Generator::getTool(ToolIndex index)
{
    if (index < 0 || index >= (int)tools.size()) {
        return NULL;
    }
    return &tools.at(index);
}

/* Tool */

Tool::Tool(std::string name, std::string path)
{
    this->name = name;
    this->path = path;
}

void Tool::setName(std::string name)
{
    this->name = name;
}

void Tool::setPath(std::string path)
{
    this->path = path;
}

std::string Tool::var()
{
    return "$(" + this->name + ")";
}

std::string &Tool::getName()
{
    return this->name;
}

std::string &Tool::getPath()
{
    return this->path;
}

/* Rule */

Rule::Rule(std::string name, std::string dep, std::string action)
{
    this->name = name;
    this->dep = dep;
    this->actions = "\t" + action + "\n";
}

void Rule::addAction(std::string action)
{
    this->actions += "\t" + action + "\n";
}

void Rule::addDep(std::string dep)
{
    this->dep += dep + " ";
}

void Rule::setName(std::string name)
{
    this->name = name;
}

std::string &Rule::getName(void)
{
    return this->name;
}

std::string &Rule::getDep(void)
{
    return this->dep;
}

std::string &Rule::getActions(void)
{
    return this->actions;
}

Variable::Variable(std::string nameVar, std::string val)
{
    this->nameVar = nameVar;
    if (!val.empty()) {
        this->val.push_back(val);
    }
    typeVar = None;
}

void Variable::addVal(std::string val)
{
    this->val.push_back(val);
}

void Variable::setName(std::string nameVar)
{
    this->nameVar = nameVar;
}

void Variable::setTypeVar(TypeVariable type)
{
    typeVar = type;
}

std::string &Variable::getName()
{
    return nameVar;
}

std::string Variable::var()
{
    return "$(" + nameVar + ")";
}

std::vector<std::string> &Variable::getVal()
{
    return val;
}

TypeVariable Variable::getTypeVar()
{
    return typeVar;
}

}
